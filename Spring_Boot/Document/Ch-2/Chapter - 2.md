## Spring Boot and Maven

When we generate spring boot projects in spring initializer we get ourselves a maven project. In this section we will cover the maven basics.

![](ch_2_10.png)

Maven is a project management tool for our application which manages dependencies. Maven saves us from getting required jar files from the corresponding project websites and adding them to our class path.

![](ch_2_11.png)

With maven installed managing dependencies become hassle free.

![](ch_2_12.png)

A project without maven is painful as we have to manually add the required dependency jars to the classpath.

![](ch_2_13.png)

Now in a project in which maven is configured, we just need to let maven know about the dependencies and maven will go out to download the jar files for us. Maven will then make these jar files make available during the compile/run time.

![](ch_2_14.png)

![](ch_2_15.png)

### Maven Behind the Scenes

![](ch_2_16.png)

1. Maven will start reading the project config file. 
2. Then it will look for the dependency in the local repository, if it finds in the local repository then the dependency will be used.
3. If the required dependency is not found in the local repository the maven reaches out for a remote repository to fetch the dependency jar. 
4. Once it is fetched it will save it to our local repository cache.
5. Once all of the above is done, maven will compile and run our project.

Also if a jar is dependent on another jar then those sub dependencies will be resolved as well.

### Maven Project Structure

Whenever we join  a new project the project structure for that particular project might be different than our previous project. This might not be a good thing and is problematic for new comers as the directory structures are not standardized.

Maven solves this problem by providing a standard directory structure.

![](ch_2_17.png)

![](ch_2_18.png)

In the above
- src -> main -> java : place for our java source code files
- src -> main -> resources : place for our java resources like properties files, config files
- src -> main -> webapp : place to keep web specific jsp files, css files other web assets (images etc)
- src -> test -> java : unit testing java source files
- src -> test -> java : unit testing java resource files like properties file or config files.
- target : place for compiled classes and resources generated by maven.

![](ch_2_19.png)

![](ch_2_20.png)

The benifit with the standard directory structure is that new comers will not have to go through a lot of trouble to know where are the resources located.

One can easily get started with the development process with ease.

![](ch_2_21.png)

Also with the standard directory structure in place the different IDEs can now import maven projects easily which makes a spring projects more portable.

![](ch_2_22.png)

## Maven Key Concepts

In this section we will understand the POM File (pom.xml) and Project Coordinates.

### POM File - pom.xml

Always located at the root of the maven project this file will contain the dependency list for our maven projects.

![](ch_2_23.png)

The POM file is going to have three components,

- Project Metadata (Project Name, version, output file type etc.)
- dependencies (List of external JARs we depend on)
- plugins (Additional custom tasks to run)

![](ch_2_24.png)

#### Simple POM File

As we can see the POM file will contain the project related information like groupId, artifactId, version and the packaging type.

It will also contain the information about the dependency lists.

Also as discussed previously we could have different plugins for custom tasks.

![](ch_2_25.png)

#### Project Coordinates

Project Coordinates uniquely identify a project.

![](ch_2_26.png)

Below we have some examples about creating project coordinates of various popular projects,

![](ch_2_27.png)

In order for us to list a dependency we will need these project coordinates in the pom files within the `<dependency></dependency>` tags. Sometimes these project coordinates are referred as GAV : Group ID, Artifact ID and Version.

We can always 

![](ch_2_28.png)
## Inversion Of Control

This is the process of outsourcing the construction and management of objects. The outsourcing is going to get handled by an object factory.

![](ch_2_1.png)
![](ch_2_2.png)


``` java
// MyApp.java (C)
package com.busybox.springdemo;:

public class MyApp {

	public static void main(String[] args) {

		// create the object use the object
		Coach baseBallCoach = new BaseBallCoach();

		Coach trackCoach = new TrackCoach();

		// use the object
		System.out.println(baseBallCoach.getDailyWorkout());
		System.out.println(trackCoach.getDailyWorkout());
	}

}
```

```java
// Coach.java (I)
package com.busybox.springdemo;

public interface Coach {
	public String getDailyWorkout();
}

```

```java
// BaseBallCoach.java (C)
package com.busybox.springdemo;

public class BaseBallCoach implements Coach {

	
	public String getDailyWorkout() {
		return "spend 30 minutes in batting practice";
	}
}
```

```java
// TrackCoach.java (C)
package com.busybox.springdemo;

public class TrackCoach implements Coach {
	@Override
	public String getDailyWorkout() {

		return "Run a hard 5k";
	}
}
```

So as we see from the code the Object creation process is hard coded the current application is not configurable. Spring was created to solve this exact problem, where we can create the type of objects we want only by changing the config file (XML config file), without us re quiring to change the source code.

![](ch_2_3.png)

### The primary functions of spring container:

1.     Create and manage objects (Inversion of Control)
2.     Inject objects dependencies (Dependency Injection)
### Ways of configuring the spring container:

1.     XML configuration file (legacy but most application will use this)
2.     Java Annotation (modern way)
3.     Java Source Code (modern way)
### Spring development process:

1. Configure your spring beans:

   ![](ch_2_4.png)

   every bean will have a id which has to be unique and will be used to retrieve beans from the bean container.
   
   In the class attribute we have to provide the fully qualified class name
   
2. Create a spring container:

   ![](ch_2_5.png)

   ![](ch_2_6.png)

   Spring container is known as *Application Context*.

3. Retrieve beans from the container : 

   ![](ch_2_7.png)

   In this step our application is going to talk to the spring container where it will ask for various objects and based on the XML config file the spring container will give us one.

   The process of bean retrieval is shown below.

   ![](ch_2_8.png)

> What is a Spring Bean?
> 
> A “Spring Bean” is simply a Java object.
> 
   When Java objects are created by the Spring Container, then Spring refers to them as “Spring Beans”. Spring Beans are created from normal Java classes …. just like Java objects.

   ![](ch_2_9.png)

Now as spring is introduced, we can wire up object implementation easily,

```java
// MyApp.java (C)
package com.busybox.springdemo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyApp {

	public static void main(String[] args) {
		
		// load the application config file
		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

		// retrieve the bean from spring container
		Coach coach1 = context.getBean("myCoach", Coach.class);
		Coach coach2 = context.getBean("baseBallCoach", Coach.class);
		
		// call methods on the bean
		System.out.println(coach1.getDailyWorkout()); // Run a hard 5k
		System.out.println(coach2.getDailyWorkout()); // spend 30 minutes in batting practice
		
		// close the context
		context.close();
	}

}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- Define your beans here -->

	<bean id="myCoach" class="com.busybox.springdemo.TrackCoach">
	</bean>
	
	<bean id="baseBallCoach" class="com.busybox.springdemo.BaseBallCoach">
	</bean>
</beans>

```

Why do we specify the Coach interface in getBean()?

For example:

``` java
Coach theCoach = context.getBean("myCoach", Coach.class); 
```

When we pass the interface to the method, behind the scenes Spring will cast the object for you.

``` java
context.getBean("myCoach", Coach.class)  
```

However, there are some slight differences than normal casting.

Behaves the same as `getBean(String), `but provides a measure of type safety by throwing a `BeanNotOfRequiredTypeException` if the bean is not of the required type. 

This means that `ClassCastException` can't be thrown on casting the result correctly, as can happen with `getBean(String)`.

